<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>StableWebRTC – Add/Stop/Resume Streams (IDs & MIDs) + Simultaneous Start/Stop</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    h1 { margin-top: 0; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    fieldset { border: 1px solid #ccc; border-radius: 10px; padding: 12px; }
    legend { padding: 0 6px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .list { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 10px; margin-top: 8px; }
    .card { border: 1px solid #e5e5e5; border-radius: 10px; padding: 8px; background: #fafafa; }
    .id  { font-family: ui-monospace, monospace; font-size: 12px; background:#eef; padding:2px 6px; border-radius: 6px; }
    .mid { font-family: ui-monospace, monospace; font-size: 12px; background:#efe; padding:2px 6px; border-radius: 6px; }
    .status { font-size: 12px; padding:2px 6px; border-radius: 6px; border:1px solid #ccc; }
    .on  { color: #0a0; border-color:#0a0; background:#f6fff6; }
    .off { color: #a00; border-color:#a00; background:#fff6f6; }
    video { width: 100%; background: #000; border-radius: 8px; }
    button { margin: 2px 0; }
    .log { font-family: ui-monospace, monospace; white-space: pre-wrap; background:#fbfbfb; border:1px solid #eee; padding:8px; height:120px; overflow:auto; }
    .toolbar { display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
  </style>
</head>
<body>
<h1>StableWebRTC</h1>

<div class="toolbar">
  <button id="startSimul">▶️ Start simultaneous (A & B)</button>
  <button id="stopAll">⏹️ Stop ALL (A & B)</button>
</div>

<div class="grid">
  <!-- Peer A -->
  <fieldset>
    <legend>Peer A</legend>
    <div class="row">
      <button id="aAdd">➕ Add Video</button>
    </div>

    <h3>A local sends (→ B)</h3>
    <div id="aSendList" class="list"></div>

    <h3>A receives (from B)</h3>
    <div id="aRecvList" class="list"></div>

    <h3>Log A</h3>
    <div id="aLog" class="log"></div>
  </fieldset>

  <!-- Peer B -->
  <fieldset>
    <legend>Peer B</legend>
    <div class="row">
      <button id="bAdd">➕ Add Video</button>
    </div>

    <h3>B local sends (→ A)</h3>
    <div id="bSendList" class="list"></div>

    <h3>B receives (from A)</h3>
    <div id="bRecvList" class="list"></div>

    <h3>Log B</h3>
    <div id="bLog" class="log"></div>
  </fieldset>
</div>

<script src="stable-webrtc.min.js"></script>
<script>
/* ======== Synthetic video (canvas) ======== */
function triangle(n, max){ var m=(max+1)*2; return Math.abs(n % m - max); }
function syntheticVideoStream(opts){
  opts = opts || {};
  var w = opts.width || 320, h = opts.height || 180, signal = opts.signal;
  var canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
  var ctx = canvas.getContext('2d');
  var stream = canvas.captureStream(); // ~30fps
  var count = 0;
  setInterval(function(){
    var r=triangle(count*2,255), g=triangle(count*3,255), b=triangle(count*5,255);
    ctx.fillStyle='rgb('+r+','+g+','+b+')'; count++;
    ctx.fillRect(0,0,w,h);
    var rc=(r+128)%256, gc=(g+128)%256, bc=(b+128)%256;
    ctx.fillStyle='rgb('+rc+','+gc+','+bc+')';
    var s=50; ctx.fillRect(triangle(count*5,w-s), triangle(count*7,h-s), s, s);
    if(signal!=null){ ctx.fillStyle='rgb('+signal+','+signal+','+signal+')'; ctx.fillRect(20,20,40,40); }
  }, 100);
  return stream;
}

/* ======== Random logical ID ======== */
function makeLogicalId(){
  var s = '', chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  for (var i=0; i<10; i++) s += chars.charAt(Math.floor(Math.random()*chars.length));
  return 'vid-' + s;
}

/* ======== In-page signaling bus with buffers ======== */
var bus = (function(){
  var listeners = {}, pending = {};
  function on(side, fn){
    if(!listeners[side]) listeners[side] = [];
    listeners[side].push(fn);
    var q = pending[side];
    if(q && q.length){
      (function flush(arr){
        function step(){ if(!arr.length) return;
          var m = arr.shift();
          var L = listeners[side] || [];
          for (var i=0;i<L.length;i++){ try{ L[i](m);}catch(e){ console.error('bus/on err', e);} }
          setTimeout(step,0);
        }
        setTimeout(step,0);
      })(q.slice());
      pending[side] = [];
    }
  }
  function send(to, msg){
    var copy=msg; 
    console.log('sending size: '+copy.length);
    //console.log(copy);

    setTimeout(function(){
      var L = listeners[to];
      if(L && L.length){
        for (var i=0;i<L.length;i++){ try{ L[i](copy);}catch(e){ console.error('bus/send err', e);} }
      } else {
        if(!pending[to]) pending[to] = [];
        pending[to].push(copy);
      }
    }, 0);
  }
  return { on:on, send:send };
}());

/* ======== Peer wrapper using your short API (stream/signal) ======== */
function makePeer(name, remoteName, ui){
  var conn = new StableWebRTC(); // assumes default ICE servers inside your lib
  var logEl = ui.log, sendList = ui.sendList, recvList = ui.recvList;

  function log(s){ logEl.textContent += s + "\n"; logEl.scrollTop = logEl.scrollHeight; }

  // Track local sends for Stop/Resume/StopAll; also store sender-MID element to update later
  var localSends = {};   // tag_id -> { track, cardEl, statusEl, videoEl, midEl }
  var remoteViews = {};  // tag_id -> { cardEl, statusEl, videoEl, midEl }

  /* --- signaling in/out --- */
  bus.on(name, function(sig){
    try { conn.signal(sig); } catch(e){ console.error(name,'signal(in) err', e); log('[ERR signal(in)] '+e); }
  });
  conn.on('signal', function(sig){
    try { bus.send(remoteName, sig); } catch(e){ console.error(name,'bus.send err', e); log('[ERR bus.send] '+e); }
  });

  /* --- diagnostics --- */
  conn.on('log', function(s){ log('[log] ' + s); });
  conn.on('connect', function(){ log('[state] ' + conn.connection); });

  /* --- receive stream updates (remote or local, depending on your lib) --- */
  conn.on('stream', function(ms, streamObj){
    
    var rec = remoteViews[streamObj.tag_id];
    if (!rec){
      rec = createRecvCard(streamObj.tag_id);
      
      remoteViews[streamObj.tag_id] = rec;
      recvList.appendChild(rec.cardEl);
    }
    if (streamObj.video_track!==null){
      rec.videoEl.srcObject = ms;
      setStatus(rec.statusEl, true);
      if (streamObj.video_mid != null) rec.midEl.textContent = 'MID: ' + String(streamObj.video_mid);
    } else {
      rec.videoEl.srcObject = null;
      setStatus(rec.statusEl, false);
      // keep last MID visible; comment next line to keep:
      // rec.midEl.textContent = 'MID: ?';
    }
  });

  /* --- UI Builders --- */
  function setStatus(el, on){
    el.textContent = on ? 'ON' : 'OFF';
    el.className = 'status ' + (on ? 'on' : 'off');
  }

  function createSendCard(tag_id, track){
    var card = document.createElement('div'); card.className = 'card';

    var top = document.createElement('div'); top.className = 'row';
    var idSpan = document.createElement('span'); idSpan.className = 'id';  idSpan.textContent  = tag_id;
    var midSpan= document.createElement('span'); midSpan.className= 'mid'; midSpan.textContent = 'MID: ?';
    var status = document.createElement('span'); setStatus(status, !!track);

    var stopBtn  = document.createElement('button'); stopBtn.textContent  = 'Stop';
    var resumeBtn= document.createElement('button'); resumeBtn.textContent= 'Resume';

    top.appendChild(idSpan);
    top.appendChild(midSpan);
    top.appendChild(status);
    top.appendChild(stopBtn);
    top.appendChild(resumeBtn);

    var vid = document.createElement('video'); vid.autoplay = true; vid.playsInline = true; vid.muted = true;

    card.appendChild(top);
    card.appendChild(vid);

    // attach locally & send
    attachTrackLocalAndSend(tag_id, track, vid, status);

    // stop: first notify library (null), then stop the track
    stopBtn.onclick = function(){
      try { conn.stream(tag_id, { video_track: null, audio_track: null }); } catch(e){ console.error('stream stop err', e); }
      vid.srcObject = null;
      setStatus(status, false);
    };

    // resume: create a fresh track and send on the same tag_id
    resumeBtn.onclick = function(){
      var s = syntheticVideoStream({ width: 320, height: 180, signal: Math.floor(Math.random()*200)+30 });
      track = s.getVideoTracks()[0];
      attachTrackLocalAndSend(tag_id, track, vid, status);
      // MID on sender will update when your lib emits a 'stream' carrying mid for this id
    };

    // if the track ends by itself
    if (track){
      track.onended = function(){
        setStatus(status, false);
        vid.srcObject = null;
        try { conn.stream(tag_id, { video_track: null, audio_track: null }); } catch(e){}
      };
    }

    return { cardEl: card, statusEl: status, videoEl: vid, midEl: midSpan, getTrack: function(){ return track; }, setTrack: function(t){ track=t; } };
  }

  function attachTrackLocalAndSend(tag_id, track, videoEl, statusEl){
    if (track){
      var ms = new MediaStream(); ms.addTrack(track);
      videoEl.srcObject = ms;
      setStatus(statusEl, true);
    } else {
      videoEl.srcObject = null;
      setStatus(statusEl, false);
    }
    try {
      conn.stream(tag_id, { video_track: track });

    } catch(e){
      console.error('stream err', e);
      log('[ERR stream] ' + e);
    }
  }

  function createRecvCard(tag_id){
    var card = document.createElement('div'); card.className = 'card';
    var top = document.createElement('div'); top.className = 'row';
    var idSpan = document.createElement('span'); idSpan.className = 'id';  idSpan.textContent  = tag_id;
    var midSpan= document.createElement('span'); midSpan.className= 'mid'; midSpan.textContent = 'MID: ?';
    var status = document.createElement('span'); setStatus(status, false);
    top.appendChild(idSpan);
    top.appendChild(midSpan);
    top.appendChild(status);

    var vid = document.createElement('video'); vid.autoplay = true; vid.playsInline = true;

    card.appendChild(top);
    card.appendChild(vid);
    return { cardEl: card, statusEl: status, videoEl: vid, midEl: midSpan };
  }

  /* --- Public API for page --- */
  function addSynthetic(){
    var tag_id = makeLogicalId();
    var s = syntheticVideoStream({ width: 320, height: 180, signal: Math.floor(Math.random()*200)+30 });
    var track = s.getVideoTracks()[0];

    var cardRec = createSendCard(tag_id, track);
    sendList.appendChild(cardRec.cardEl);

    localSends[tag_id] = {
      cardEl: cardRec.cardEl,
      statusEl: cardRec.statusEl,
      videoEl: cardRec.videoEl,
      midEl: cardRec.midEl,
      get track(){ return cardRec.getTrack(); },
      set track(v){ cardRec.setTrack(v); }
    };
  }

  function stopAllLocal(){
    // For every local tag_id: send null first, then stop tracks, update UI
    for (var id in localSends){
      if (!localSends.hasOwnProperty(id)) continue;
      try { conn.stream(id, { video_track: null, audio_track: null }); } catch(e){}
      var t = localSends[id].track;
      localSends[id].videoEl.srcObject = null;
      setStatus(localSends[id].statusEl, false);
    }
  }

  function addOneSimultaneous(){
    // Create exactly one new stream for this peer (used by global “Start simultaneous”)
    var tag_id = makeLogicalId();
    var s = syntheticVideoStream({ width: 320, height: 180, signal: Math.floor(Math.random()*200)+30 });
    var track = s.getVideoTracks()[0];
    var cardRec = createSendCard(tag_id, track);
    sendList.appendChild(cardRec.cardEl);
    localSends[tag_id] = {
      cardEl: cardRec.cardEl,
      statusEl: cardRec.statusEl,
      videoEl: cardRec.videoEl,
      midEl: cardRec.midEl,
      get track(){ return cardRec.getTrack(); },
      set track(v){ cardRec.setTrack(v); }
    };
  }

  return {
    conn: conn,
    addSynthetic: addSynthetic,
    stopAllLocal: stopAllLocal,
    addOneSimultaneous: addOneSimultaneous,
    // expose locals for debugging if you wish:
    _locals: localSends,
    log: log
  };
}

/* ======== Instantiate peers ======== */
var A = makePeer('A','B', {
  sendList: document.getElementById('aSendList'),
  recvList: document.getElementById('aRecvList'),
  log:      document.getElementById('aLog')
});
var B = makePeer('B','A', {
  sendList: document.getElementById('bSendList'),
  recvList: document.getElementById('bRecvList'),
  log:      document.getElementById('bLog')
});

/* ======== Buttons ======== */
document.getElementById('aAdd').onclick = function(){ A.addSynthetic(); };
document.getElementById('bAdd').onclick = function(){ B.addSynthetic(); };

// Global: simultaneous start → add exactly one new stream on both sides at the same time
document.getElementById('startSimul').onclick = function(){
  // Use same event turn to provoke glare
  setTimeout(function(){ A.addOneSimultaneous(); }, 0);
  setTimeout(function(){ B.addOneSimultaneous(); }, 0);
};

// Global: stop ALL on both sides simultaneously (send nulls first, then stop)
document.getElementById('stopAll').onclick = function(){
  setTimeout(function(){ A.stopAllLocal(); }, 0);
  setTimeout(function(){ B.stopAllLocal(); }, 0);
};
</script>
</body>
</html>
